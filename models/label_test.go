package models

import (
	"testing"
	"time"

	"github.com/google/uuid"
	"github.com/stretchr/testify/assert"
	"gorm.io/driver/sqlite"
	"gorm.io/gorm"
)

// setupLabelTestDB creates an in-memory SQLite database for testing Label model
func setupLabelTestDB(t *testing.T) *gorm.DB {
	db, err := gorm.Open(sqlite.Open(":memory:"), &gorm.Config{})
	assert.NoError(t, err, "Failed to connect to test database")

	err = db.Exec("PRAGMA foreign_keys = ON").Error
	assert.NoError(t, err, "Failed to enable foreign keys")

	// Migrate all models needed for Label tests
	err = db.AutoMigrate(&User{}, &Board{}, &Column{}, &Task{}, &Label{}, &TaskLabel{})
	assert.NoError(t, err, "Failed to migrate database")

	err = db.Exec(`
		CREATE TABLE IF NOT EXISTS audit_logs (
			id VARCHAR(36) PRIMARY KEY,
			user_id VARCHAR(36) NOT NULL,
			action VARCHAR(50) NOT NULL,
			message TEXT,
			created_at DATETIME
		)
	`).Error
	assert.NoError(t, err, "Failed to create audit_logs table")

	return db
}

// TestLabelModel verifies Label struct fields and GORM tags
func TestLabelModel(t *testing.T) {
	label := Label{
		ID:        uuid.NewString(),
		Name:      "Bug",
		Color:     "#FF0000",
		CreatedAt: time.Now(),
		UpdatedAt: time.Now(),
	}

	// Verify ID is a valid UUID
	_, err := uuid.Parse(label.ID)
	assert.NoError(t, err, "Label ID should be a valid UUID")

	// Verify required fields are set
	assert.NotEmpty(t, label.Name, "Name should not be empty")
	assert.NotEmpty(t, label.Color, "Color should not be empty")
	assert.False(t, label.CreatedAt.IsZero(), "CreatedAt should be set")
	assert.False(t, label.UpdatedAt.IsZero(), "UpdatedAt should be set")

	// Verify TableName
	assert.Equal(t, "labels", label.TableName(), "TableName should be 'labels'")
}

// TestLabelTableName verifies the TableName method
func TestLabelTableName(t *testing.T) {
	label := Label{}
	assert.Equal(t, "labels", label.TableName(), "TableName should return 'labels'")
}

// TestLabelBeforeCreate verifies BeforeCreate hook sets UUID
func TestLabelBeforeCreate(t *testing.T) {
	db := setupLabelTestDB(t)

	// Create label without setting ID
	label := Label{
		Name:      "Feature",
		Color:     "#00FF00",
		CreatedAt: time.Now(),
		UpdatedAt: time.Now(),
	}

	// Save to database (this will trigger BeforeCreate hook)
	err := db.Create(&label).Error
	assert.NoError(t, err, "Failed to create label")

	// Verify ID was auto-generated by BeforeCreate hook
	assert.NotEmpty(t, label.ID, "ID should be set by BeforeCreate hook")

	// Verify ID is a valid UUID
	_, err = uuid.Parse(label.ID)
	assert.NoError(t, err, "Auto-generated ID should be a valid UUID")
}

// TestLabelDatabase verifies Label can be saved to database
func TestLabelDatabase(t *testing.T) {
	db := setupLabelTestDB(t)

	// Create a test label
	label := Label{
		ID:        uuid.NewString(),
		Name:      "High Priority",
		Color:     "#FF5733",
		CreatedAt: time.Now(),
		UpdatedAt: time.Now(),
	}
	err := db.Create(&label).Error
	assert.NoError(t, err, "Failed to create label")

	// Verify label was created with correct ID
	var retrievedLabel Label
	err = db.First(&retrievedLabel, "id = ?", label.ID).Error
	assert.NoError(t, err, "Failed to retrieve label")
	assert.Equal(t, label.ID, retrievedLabel.ID, "Label ID should match")
	assert.Equal(t, label.Name, retrievedLabel.Name, "Label Name should match")
	assert.Equal(t, label.Color, retrievedLabel.Color, "Label Color should match")
}

// TestLabelNameUnique verifies Name field has unique constraint
func TestLabelNameUnique(t *testing.T) {
	db := setupLabelTestDB(t)

	// Create first label
	label1 := Label{
		ID:        uuid.NewString(),
		Name:      "Bug",
		Color:     "#FF0000",
		CreatedAt: time.Now(),
		UpdatedAt: time.Now(),
	}
	err := db.Create(&label1).Error
	assert.NoError(t, err, "Failed to create first label")

	// Try to create second label with same name
	label2 := Label{
		ID:        uuid.NewString(),
		Name:      "Bug", // Duplicate name
		Color:     "#0000FF",
		CreatedAt: time.Now(),
		UpdatedAt: time.Now(),
	}
	err = db.Create(&label2).Error
	assert.Error(t, err, "Should fail to create label with duplicate name")
}

// TestLabelTaskRelationship verifies many-to-many relationship with Task
func TestLabelTaskRelationship(t *testing.T) {
	db := setupLabelTestDB(t)

	// Create test user
	userID := uuid.NewString()
	user := User{
		ID:        userID,
		Email:     "test@example.com",
		CreatedAt: time.Now(),
		UpdatedAt: time.Now(),
	}
	err := db.Create(&user).Error
	assert.NoError(t, err, "Failed to create test user")

	// Create test board
	boardID := uuid.NewString()
	board := Board{
		ID:        boardID,
		Title:     "Test Board",
		UserID:    userID,
		Color:     "#FF5733",
		CreatedAt: time.Now(),
		UpdatedAt: time.Now(),
	}
	err = db.Create(&board).Error
	assert.NoError(t, err, "Failed to create test board")

	// Create test column
	columnID := uuid.NewString()
	column := Column{
		ID:        columnID,
		BoardID:   boardID,
		Title:     "To Do",
		Order:     1,
		CreatedAt: time.Now(),
		UpdatedAt: time.Now(),
	}
	err = db.Create(&column).Error
	assert.NoError(t, err, "Failed to create test column")

	// Create labels
	label1 := Label{
		ID:        uuid.NewString(),
		Name:      "Bug",
		Color:     "#FF0000",
		CreatedAt: time.Now(),
		UpdatedAt: time.Now(),
	}
	label2 := Label{
		ID:        uuid.NewString(),
		Name:      "Feature",
		Color:     "#00FF00",
		CreatedAt: time.Now(),
		UpdatedAt: time.Now(),
	}
	err = db.Create(&label1).Error
	assert.NoError(t, err, "Failed to create label1")
	err = db.Create(&label2).Error
	assert.NoError(t, err, "Failed to create label2")

	// Create tasks
	task1 := Task{
		ID:        uuid.NewString(),
		ColumnID:  columnID,
		Title:     "Fix login bug",
		CreatedAt: time.Now(),
		UpdatedAt: time.Now(),
	}
	task2 := Task{
		ID:        uuid.NewString(),
		ColumnID:  columnID,
		Title:     "Add search feature",
		CreatedAt: time.Now(),
		UpdatedAt: time.Now(),
	}
	err = db.Create(&task1).Error
	assert.NoError(t, err, "Failed to create task1")
	err = db.Create(&task2).Error
	assert.NoError(t, err, "Failed to create task2")

	// Associate labels with tasks via TaskLabel join table
	// Task1 has Bug label
	taskLabel1 := TaskLabel{
		TaskID:    task1.ID,
		LabelID:   label1.ID,
		CreatedAt: time.Now(),
	}
	// Task2 has Feature label
	taskLabel2 := TaskLabel{
		TaskID:    task2.ID,
		LabelID:   label2.ID,
		CreatedAt: time.Now(),
	}
	// Task2 also has Bug label
	taskLabel3 := TaskLabel{
		TaskID:    task2.ID,
		LabelID:   label1.ID,
		CreatedAt: time.Now(),
	}
	err = db.Create(&taskLabel1).Error
	assert.NoError(t, err, "Failed to create taskLabel1")
	err = db.Create(&taskLabel2).Error
	assert.NoError(t, err, "Failed to create taskLabel2")
	err = db.Create(&taskLabel3).Error
	assert.NoError(t, err, "Failed to create taskLabel3")

	// Verify label can load associated tasks via relationship
	var labelWithTasks Label
	err = db.Preload("Tasks").First(&labelWithTasks, "id = ?", label1.ID).Error
	assert.NoError(t, err, "Failed to load label with tasks")
	assert.Len(t, labelWithTasks.Tasks, 2, "Bug label should be associated with 2 tasks")

	// Verify feature label has 1 task
	var featureLabelWithTasks Label
	err = db.Preload("Tasks").First(&featureLabelWithTasks, "id = ?", label2.ID).Error
	assert.NoError(t, err, "Failed to load feature label with tasks")
	assert.Len(t, featureLabelWithTasks.Tasks, 1, "Feature label should be associated with 1 task")
	assert.Equal(t, "Add search feature", featureLabelWithTasks.Tasks[0].Title, "Task title should match")
}

// TestLabelSoftDelete verifies Label soft delete functionality
func TestLabelSoftDelete(t *testing.T) {
	db := setupLabelTestDB(t)

	// Create test label
	label := Label{
		ID:        uuid.NewString(),
		Name:      "Deleted Label",
		Color:     "#FF5733",
		CreatedAt: time.Now(),
		UpdatedAt: time.Now(),
	}
	err := db.Create(&label).Error
	assert.NoError(t, err, "Failed to create label")

	// Verify label exists
	var retrievedLabel Label
	err = db.First(&retrievedLabel, "id = ?", label.ID).Error
	assert.NoError(t, err, "Label should exist before delete")

	// Soft delete label
	err = db.Delete(&label).Error
	assert.NoError(t, err, "Failed to soft delete label")

	// Verify label is soft deleted (not found with regular query)
	err = db.First(&retrievedLabel, "id = ?", label.ID).Error
	assert.Error(t, err, "Label should not be found with regular query after soft delete")

	// Verify label can be found with Unscoped
	err = db.Unscoped().First(&retrievedLabel, "id = ?", label.ID).Error
	assert.NoError(t, err, "Label should be found with Unscoped query")
	assert.Equal(t, label.ID, retrievedLabel.ID, "Label ID should match after soft delete")
}

// TestLabelGORMTags verifies GORM tags are correct
func TestLabelGORMTags(t *testing.T) {
	db := setupLabelTestDB(t)

	// Get the schema for Label model
	stmt := &gorm.Statement{DB: db}
	err := stmt.Parse(&Label{})
	assert.NoError(t, err, "Failed to parse Label model")

	// Verify primary key
	assert.Equal(t, "ID", stmt.Schema.PrimaryFields[0].Name, "Primary key should be ID")

	// Verify required fields have not null tag
	for _, field := range stmt.Schema.Fields {
		switch field.Name {
		case "Name":
			assert.True(t, field.NotNull, "Name should have not null tag")
		}
	}

	// Verify field sizes
	for _, field := range stmt.Schema.Fields {
		switch field.Name {
		case "Name":
			assert.Equal(t, 255, field.Size, "Name size should be 255")
		case "Color":
			assert.Equal(t, 255, field.Size, "Color size should be 255")
		}
	}

	// Verify many-to-many relationship with Task
	hasTaskRelationship := false
	for _, rel := range stmt.Schema.Relationships.Relations {
		if rel.Name == "Tasks" {
			hasTaskRelationship = true
			break
		}
	}
	assert.True(t, hasTaskRelationship, "Label should have Tasks relationship")
}

// TestTaskLabelModel verifies TaskLabel join model
func TestTaskLabelModel(t *testing.T) {
	taskLabel := TaskLabel{
		TaskID:    uuid.NewString(),
		LabelID:   uuid.NewString(),
		CreatedAt: time.Now(),
	}

	// Verify TaskID is a valid UUID
	_, err := uuid.Parse(taskLabel.TaskID)
	assert.NoError(t, err, "TaskID should be a valid UUID")

	// Verify LabelID is a valid UUID
	_, err = uuid.Parse(taskLabel.LabelID)
	assert.NoError(t, err, "LabelID should be a valid UUID")

	// Verify required fields are set
	assert.NotEmpty(t, taskLabel.TaskID, "TaskID should not be empty")
	assert.NotEmpty(t, taskLabel.LabelID, "LabelID should not be empty")
	assert.False(t, taskLabel.CreatedAt.IsZero(), "CreatedAt should be set")

	// Verify TableName
	assert.Equal(t, "task_labels", taskLabel.TableName(), "TableName should be 'task_labels'")
}

// TestTaskLabelTableName verifies the TableName method for TaskLabel
func TestTaskLabelTableName(t *testing.T) {
	taskLabel := TaskLabel{}
	assert.Equal(t, "task_labels", taskLabel.TableName(), "TableName should return 'task_labels'")
}

// TestTaskLabelDatabase verifies TaskLabel can be saved to database
func TestTaskLabelDatabase(t *testing.T) {
	db := setupLabelTestDB(t)

	// Create test user, board, column, task, and label
	userID := uuid.NewString()
	user := User{
		ID:        userID,
		Email:     "test@example.com",
		CreatedAt: time.Now(),
		UpdatedAt: time.Now(),
	}
	err := db.Create(&user).Error
	assert.NoError(t, err, "Failed to create test user")

	boardID := uuid.NewString()
	board := Board{
		ID:        boardID,
		Title:     "Test Board",
		UserID:    userID,
		Color:     "#FF5733",
		CreatedAt: time.Now(),
		UpdatedAt: time.Now(),
	}
	err = db.Create(&board).Error
	assert.NoError(t, err, "Failed to create test board")

	columnID := uuid.NewString()
	column := Column{
		ID:        columnID,
		BoardID:   boardID,
		Title:     "To Do",
		Order:     1,
		CreatedAt: time.Now(),
		UpdatedAt: time.Now(),
	}
	err = db.Create(&column).Error
	assert.NoError(t, err, "Failed to create test column")

	taskID := uuid.NewString()
	task := Task{
		ID:        taskID,
		ColumnID:  columnID,
		Title:     "Test Task",
		CreatedAt: time.Now(),
		UpdatedAt: time.Now(),
	}
	err = db.Create(&task).Error
	assert.NoError(t, err, "Failed to create test task")

	labelID := uuid.NewString()
	label := Label{
		ID:        labelID,
		Name:      "Test Label",
		Color:     "#FF0000",
		CreatedAt: time.Now(),
		UpdatedAt: time.Now(),
	}
	err = db.Create(&label).Error
	assert.NoError(t, err, "Failed to create test label")

	// Create TaskLabel association
	taskLabel := TaskLabel{
		TaskID:    taskID,
		LabelID:   labelID,
		CreatedAt: time.Now(),
	}
	err = db.Create(&taskLabel).Error
	assert.NoError(t, err, "Failed to create TaskLabel")

	// Verify TaskLabel was created
	var retrievedTaskLabel TaskLabel
	err = db.First(&retrievedTaskLabel, "task_id = ? AND label_id = ?", taskID, labelID).Error
	assert.NoError(t, err, "Failed to retrieve TaskLabel")
	assert.Equal(t, taskID, retrievedTaskLabel.TaskID, "TaskID should match")
	assert.Equal(t, labelID, retrievedTaskLabel.LabelID, "LabelID should match")
}

// TestTaskLabelCascadeDelete verifies CASCADE delete behavior
func TestTaskLabelCascadeDelete(t *testing.T) {
	db := setupLabelTestDB(t)

	// Create test data
	userID := uuid.NewString()
	user := User{
		ID:        userID,
		Email:     "test@example.com",
		CreatedAt: time.Now(),
		UpdatedAt: time.Now(),
	}
	err := db.Create(&user).Error
	assert.NoError(t, err, "Failed to create test user")

	boardID := uuid.NewString()
	board := Board{
		ID:        boardID,
		Title:     "Test Board",
		Color:     "#FF5733",
		CreatedAt: time.Now(),
		UpdatedAt: time.Now(),
	}
	err = db.Create(&board).Error
	assert.NoError(t, err, "Failed to create test board")

	columnID := uuid.NewString()
	column := Column{
		ID:        columnID,
		Title:     "To Do",
		Order:     1,
		CreatedAt: time.Now(),
		UpdatedAt: time.Now(),
	}
	err = db.Create(&column).Error
	assert.NoError(t, err, "Failed to create test column")

	taskID := uuid.NewString()
	task := Task{
		ID:        taskID,
		ColumnID:  columnID,
		Title:     "Test Task",
		CreatedAt: time.Now(),
		UpdatedAt: time.Now(),
	}
	err = db.Create(&task).Error
	assert.NoError(t, err, "Failed to create test task")

	labelID := uuid.NewString()
	label := Label{
		ID:        labelID,
		Name:      "Test Label",
		Color:     "#FF0000",
		CreatedAt: time.Now(),
		UpdatedAt: time.Now(),
	}
	err = db.Create(&label).Error
	assert.NoError(t, err, "Failed to create test label")

	// Create TaskLabel association
	taskLabel := TaskLabel{
		TaskID:    taskID,
		LabelID:   labelID,
		CreatedAt: time.Now(),
	}
	err = db.Create(&taskLabel).Error
	assert.NoError(t, err, "Failed to create TaskLabel")

	// Verify TaskLabel exists
	var retrievedTaskLabel TaskLabel
	err = db.First(&retrievedTaskLabel, "task_id = ? AND label_id = ?", taskID, labelID).Error
	assert.NoError(t, err, "TaskLabel should exist before delete")

	// Delete task (should cascade delete TaskLabel due to OnDelete:CASCADE)
	err = db.Delete(&task).Error
	assert.NoError(t, err, "Failed to delete task")

	// Verify TaskLabel was cascade deleted
	err = db.Unscoped().First(&retrievedTaskLabel, "task_id = ? AND label_id = ?", taskID, labelID).Error
	assert.Error(t, err, "TaskLabel should be cascade deleted when task is deleted")
}
